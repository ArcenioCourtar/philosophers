philo start benchmarks in microseconds (on f1r6s7).
these benchmarks include a single printf call for each philo with their number 
and timestamp.

1: Setting start time and letting all threads run as soon as they're created.
10	|	180 - 350
50	|	650 - 950
100	|	1200 - 1600
200	|	2400 - 2700

2A: Creating all threads, and have them wait behind a single mutex before 
setting start time.
10	|	50 - 250
50	|	500 - 900
100	|	900 - 1400
200	|	2100 - 2600
Faster on average than method #1, but the worst case has pretty much the same delay

2B: Creating all threads, and have them loop through a mutex locked variable
until that variable changes. Same mutex for all threads.
(no usleep)				usleep(50)
10	|	40 - 120 		10	|	100 - 200
50	|	120 - 450		50	|	250 - 400
100	|	300 - 1400		100	|	400 - 650
200	|	400 - 1800		200	|	450 - 700

A massive improvement, both with and without the use of usleep()! 
At philo counts at or below 10 it's consistently better to not call usleep at all.
Afterwards it's still faster to not use usleep() in the best case, but the
CPU-hogging can make this wildly inconsistent.
usleep() prevents constant CPU-hogging, making the best cases slightly worse,
especially at lower philo counts, but the worst cases have been greatly improved.

3: Creating all threads, and having them wait behind separate mutexes before setting start time.
No discernible performance change between this and solution 2B.
Except the code is now way harder to debug.

Might be worth experimenting with in other parts of the program, though.